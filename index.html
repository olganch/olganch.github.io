<!DOCTYPE html>
<html>
    
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>quick introduction to oop</title>
        <meta name="description" content="An interactive getting started guide for OOP.">
        <link rel="stylesheet" href="main.css">
        <link href="https://fonts.googleapis.com/css?family=Amatic+SC&display=swap" rel="stylesheet">
    </head>
    <body>
        <a href="https://raw.githubusercontent.com/olganch/olganch.github.io/master/coffee_warm_lifestyle.jpg">
            <img src="https://raw.githubusercontent.com/olganch/olganch.github.io/master/coffee_warm_lifestyle.jpg" alt="This screenshot is repesenting
                                                                                                                        my lifestyle" width="510" heigh="410" />
        </a>
        
        <h1>БЫСТРОЕ ВВЕДЕНИЕ В ООП - К ЭКЗАМЕНУ ПО ИСРППС ДЛЯ МОИХ ОДНОГРУППНИКОВ</h1>
        <h1 class="title">Сделано приматом для приматов</h1>
        <p>
            <b>Класс</b> - это пользовательский тип данных, т.е. свой новый тип данных, который мы можем создать (с точки зрения структуры программы). Еще это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).
        </p>
        
        <p>
        <b>Объект (экземпляр)</b> – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Проще говоря, объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.
        </p>
        
        <p>
            <b>Спецификация</b> используется для описания, что есть объект и что объект делает. <b>Реализация</b> описывает, как объект реализован.
        </p>

        <p>
            <b>Интерфейс</b> - это набор методов класса, доступных для использования другими классами. Очевидно, что интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним. Интерфейсом могут быть методы экземпляров. 
            
        </p>
        <p>
            <b>Категория </b>как математическое понятие имеет дело c абстрактными математическими структурами и отношениями между ними. Отношения между классами объектов моделируются математикой и логикой. Такая модель коллекции объектов с некоторым структурным подобием определяется категорией.<br><br> 
        </p>
        
        <hr width="60%" align="center" color="708090">
        
        <h3><b>Объектно-ориентированная парадигма</b> поддерживает следующие принципы: инкапсуляцию, наследование, полиморфизм и, очевидно, абстракцию. Рассмотрим эти механизмы:</h3>
        <p>
            <b>Абстрагирование</b> - это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция - это набор всех таких характеристик. Если бы для моделирования поведения автомобиля приходилось учитывать химический состав краски кузова и удельную теплоёмкость лампочки подсветки номеров, мы никогда бы не узнали, что такое NFS.<br><br>

            <b>Инкапсуляция</b> - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя. Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсулируется в классе.<br><br>

            <b>Полиморфизм</b> - это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Определение поведения в зависимости от реализации (ну, примерно). (Класс может иметь одни и те же методы, но вести себя они будут по-разному.)<br><br>

            <b>Наследование</b> - это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующимся функционалом. Класс, от которого производится наследование, называется базовым или родительским (супер-классом). Новый класс – потомком, наследником или производным классом. Необходимо отметить, что производный класс полностью удовлетворяет спецификации родительского, однако может иметь дополнительный функционал. С точки зрения интерфейсов: каждый производный класс полностью реализует интерфейс родительского класса, а обратное не верно.<br>
        </p>
        
        <hr width="60%" align="center" color="708090">
        
        <p><br>
            По умолчанию Private <b>модификатор доступа</b>. Он даёт доступ дружественным классам и функциям и, очевидно, поле доступно внутри самого класса (пример с методом Print()). Модификаторы доступа относятся к областям. Protected позволяет наследовать поля, но не даёт доступ извне.
        </p>

            <p><b>Геттеры и сеттеры</b> - существуют, чтобы не нарушать инкапсуляцию; обыкновенные методы (методы чтения и изменения, строго говоря) класса, собственно, они же функции, которые отвечают за то, чтобы взаимодействовать с каким-то конкретным полем. Защищают от того, что пользователь может засунуть говнище в поле класса, просто обратившись к нему, если мы вдруг захотели оставить это поле в области Public.  Мы ведь, как разработчики, могли предусматривать какую-то другую работу с этим классом и его конкретным полем. Геттеры - позволяют получить данные, а сеттеры - установить данные. 
        </p>

        <p>
            Важно отметить, что в ООП существует особый тип классов — <b>абстрактные классы</b>. <b>Абстрактные классы</b> — это классы для которых не существует экземпляров, они лишь описывают общие характеристики классов-потомков (противоположность <b>конкретного</b> класса).
        </p>
        
        
        <p><b>// This</b> - хранит адрес памяти объекта. Хранит ссылку на самого себя. Помогает устранять неоднозначности. 
        </p>
        <p>
            <b>Иерархия</b> — упорядоченная система абстракций. Структурная ие􏰀рархия — отражает взаимосвязи типа «часть — целое» и определяет от􏰀ношение агрегирования между объектами. (Значительное упрощение в понимании сложных задач достигается за счет образования из абстракций иерархической структуры. Это расположение частей или элементов целого от высшего к низшему, упорядочение абстракций, расположение их по уровням. Одним из важных видов иерархии является наследование.) 
            В ООП используют два вида иерархии. Иерархия <b>«целое–часть»</b> показывает, что некоторые абстракции включены в некоторую абстракцию как ее части, например, строение цветка описывается следующими частями: цветоложе, пестик, тычинки, цветоножка, завязь, лепестки. Этот вариант иерархии используется в процессе разбиения системы на разных этапах проектирования (на логическом уровне — при декомпозиции предметной области на объекты, на физическом уровне — при декомпозиции системы на модули и при выделении отдельных процессов в мультипроцессорной системе). Иерархия <b>«общее–частное»</b> — показывает, что некоторая абстракция является частным случаем другой абстракции, например, ель — это разновидность хвойных деревьев, а деревья — это часть растительного мира планеты. Используется при разработке структуры классов, когда сложные классы строятся на базе более простых путем добавления к ним новых характеристик и, возможно, уточнения имеющихся.
        </p>
        
        <p>
            <b>Виртуальные функции</b> - классы будут иметь одни и те же методы, но вести они себя буду по-разному. Виртуальные функции - специальный вид функций-членов класса. Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы. Определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс <a href="https://prog-cpp.ru/cpp-virtual">(подробнее о виртуальных функциях)</a>. Под <b>перегрузкой</b> функции понимается определение нескольких функций с одинаковыми именами, но различными параметрами. Наборы параметров перегруженных функций могут отличаться порядком следования, количеством, типом. Таким образом перегрузка нужна для того, чтобы избежать дублирования функций, выполняющих сходные действия, но с различной программной логикой <a href="http://cppstudio.com/post/406">(подробнее о перегрузке)</a>.
       </p>
        <p>Метод выстрелить - классный пример виртуальной функции. От класса Gun можно унаследовать пистолет, пулемет и т. д., а в наследуемых классах переопределять метод Gang в зависимости от оружия (одиночный выстрел, очередь и т. д.).</p>
        
        <p>virtual void gang<br></p>
        <p style="margin-left: 50px;">...</p>
        <p style="margin-left: 50px;">переопределяем void gang в наследованном классе</p>
        <p><em>Указатель на базовый класс может принимать ссылки на любого своего наследника.</em></p>
        
        <a href="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/master/ScreenshotGun.png">
            <img src="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/master/ScreenshotGun.png" alt="A screenshot showing OOP" width="790" heigh="510" />
        </a>
        
        <p>Кстати, в примере с оружием Gun - не супер-корректно. Чисто формально, мы могли и должны были создать абстрактный Вооружение и наследовать от него все наше оружие (в том числе нож, пулемёт и т. д.), ведь особенность этого всего - наносить урон и делать это должен любой вид оружия. Рассмотрим еще один достаточно простой пример с зоопраком: </p>
        
         <a href="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/915c7a73e0eb92e8b469daf230fda825d13751e6/ScreenshotZoo.png">
            <img src="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/915c7a73e0eb92e8b469daf230fda825d13751e6/ScreenshotZoo.png" alt="A screenshot showing OOP" width="790" heigh="510" />
        </a>
        
        <p>
            <b>Категория агрегация</b>. Отношение агрегация применяется для создания иерархии «Целое — часть», также известное как правило «has􏰀-a». От композиции следует отличать агрегацию: она также предполагает отношение «has􏰀-a», но реализуется она иначе. При агрегации реализуется слабая связь, то есть в данном случае объекты Car и Engine будут равноправны. В конструктор Car передается ссылка на уже имеющийся объект Engine. И, как правило, определяется ссылка не на конкретный класс, а на абстрактный класс или интерфейс, что увеличивает гибкость программы.
        </p>
        
        <p>
         <b>Категория наследование.</b> Отношение наследование применяется в иерархии «Общее — Частное», также известное как правило «is􏰀-a». Объекты организуются в иерархическую структуру с наследованием свойств и методов (функций и операций).
         </p>
        
        <p>
        <b>Категория ассоциация. </b>Отношение ассоциация — смысловое семаннтическое отношение, указывающее семантическую двухстороннюю зависимость объектов классов A:B.
        </p> 
        
        <p>
            <b>Категория использование.</b> Отношение использование — односто􏰀 роннее отношение между объектами: ресурс одного объекта, высту􏰀 пающего в качестве сервиса, используется другим объектом, высту􏰀 пающим в качестве клиента.
        </p>
        
        <p><b>Категория конкретизация.</b> Отношение конкретизации возникает между объектами, когда класс, выступающий в качестве шаблона (temp􏰀late в C++, generic в Java, Ada) с параметрами, конкретизируется другим классом. В параметр(ы) шаблона подставляется класс.
        </p>
        
         <a href="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/master/ScreenshotCategories.png">
            <img src="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/master/ScreenshotCategories.png" alt="A screenshot showing OOP" width="510" heigh="410" />
        </a>
        
        <p>
        Давайте теперь обсудим <b>принцип подстановки</b>, известный так же как Принцип подстановки Барбары Лисков (Валентин Евгеньевич, да-да, здравствуйте). <br> Итак, формулировка: "Пусть q(x) является свойством верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T.". Звучит красиво, это правда, но, проще говоря, следует всего лишь уяснить, что наследующий класс должен дополнять, а не замещать поведение базового класса. Всё. Надеюсь, все понимают, что принцип Лисков — это из области теории ООП. На практике же никто не заставляет следовать ему при любых обстоятельствах, более того, могут быть случаи, когда следовать ему сложно и ненужно.
            <br>Из этого можно сделать выводы: следование принципу подстановки Лисков делает ваш проект ближе к духу ООП; это позволит избежать ряда ошибок.
        </p>
         <a href="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/master/9b871ba0b4fe575aa9d896a6d642c55a.jpg">
            <img src="https://raw.githubusercontent.com/lyoleech/lyoleech.github.io/master/9b871ba0b4fe575aa9d896a6d642c55a.jpg" alt="A screenshot showing Liskov Principle" width="350" heigh="280" />
        </a>
    </body>
</html>
